// Generated by CoffeeScript 1.6.3
(function() {
  var AngleConstraint, DistanceConstraint, Point, canvasEl, clear, config, ctx, drawCircle, drawLine, drawPoint, enforceConstraints, findPointNear, idle, idleLoop, init, math, model, pointerDown, pointerMove, pointerUp, render, resize, uistate;

  canvasEl = document.querySelector("#c");

  ctx = canvasEl.getContext("2d");

  resize = function() {
    var rect;
    rect = canvasEl.getBoundingClientRect();
    canvasEl.width = rect.width;
    canvasEl.height = rect.height;
    return render();
  };

  init = function() {
    window.addEventListener("resize", resize);
    canvasEl.addEventListener("pointerdown", pointerDown);
    canvasEl.addEventListener("pointermove", pointerMove);
    canvasEl.addEventListener("pointerup", pointerUp);
    resize();
    return idleLoop();
  };

  idleLoop = function() {
    idle();
    return requestAnimationFrame(idleLoop);
  };

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  DistanceConstraint = (function() {
    function DistanceConstraint(p1, p2, distance) {
      this.p1 = p1;
      this.p2 = p2;
      this.distance = distance;
    }

    DistanceConstraint.prototype.pointNames = function() {
      return ["p1", "p2"];
    };

    DistanceConstraint.prototype.solveFor = function(pointName) {
      var direction, dx, dy, x, y;
      dx = this.p2.x - this.p1.x;
      dy = this.p2.y - this.p1.y;
      direction = math.normalize(new Point(dx, dy));
      if (pointName === "p1") {
        x = this.p2.x - direction.x * this.distance;
        y = this.p2.y - direction.y * this.distance;
      } else if (pointName === "p2") {
        x = this.p1.x + direction.x * this.distance;
        y = this.p1.y + direction.y * this.distance;
      }
      return new Point(x, y);
    };

    DistanceConstraint.prototype.error = function() {
      var d, e;
      d = math.distance(this.p1, this.p2);
      e = d - this.distance;
      return e * e;
    };

    return DistanceConstraint;

  })();

  AngleConstraint = (function() {
    function AngleConstraint(p1, p2, angle) {
      this.p1 = p1;
      this.p2 = p2;
      this.angle = angle;
    }

    AngleConstraint.prototype.pointNames = function() {
      return ["p1", "p2"];
    };

    AngleConstraint.prototype.solveFor = function(pointName) {
      var cos, dx, dy, parallelComponent, sin, x, y;
      dx = this.p2.x - this.p1.x;
      dy = this.p2.y - this.p1.y;
      cos = Math.cos(this.angle);
      sin = Math.sin(this.angle);
      parallelComponent = cos * dx + sin * dy;
      if (pointName === "p1") {
        x = this.p2.x - parallelComponent * cos;
        y = this.p2.y - parallelComponent * sin;
      } else if (pointName === "p2") {
        x = this.p1.x + parallelComponent * cos;
        y = this.p1.y + parallelComponent * sin;
      }
      return new Point(x, y);
    };

    AngleConstraint.prototype.error = function() {
      var angle, da, e;
      angle = math.angle(this.p1, this.p2);
      da = angle - this.angle;
      e = math.distance(this.p1, this.p2) * Math.sin(da);
      return e * e;
    };

    return AngleConstraint;

  })();

  window.model = model = {
    points: [],
    constraints: []
  };

  uistate = {
    movingPoint: null,
    lastTouchedPoints: [],
    pointerX: 0,
    pointerY: 0
  };

  clear = function() {
    var height, width;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    width = ctx.canvas.width;
    height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);
    return ctx.restore();
  };

  drawPoint = function(point, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    return ctx.fill();
  };

  drawCircle = function(center, radius, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  drawLine = function(p1, p2, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  render = function() {
    var color, constraint, point, _i, _j, _len, _len1, _ref, _ref1, _results;
    clear();
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      color = "#000";
      if (point === uistate.lastTouchedPoints[0]) {
        color = "#f00";
      }
      if (point === uistate.lastTouchedPoints[1]) {
        color = "#a00";
      }
      drawPoint(point, color);
      if (point.fixed) {
        drawCircle(point, 5, color);
      }
    }
    _ref1 = model.constraints;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      constraint = _ref1[_j];
      if (constraint instanceof DistanceConstraint) {
        drawLine(constraint.p1, constraint.p2, "blue");
      }
      if (constraint instanceof AngleConstraint) {
        _results.push(drawLine(constraint.p1, constraint.p2, "red"));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  findPointNear = function(p) {
    var point, _i, _len, _ref;
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (math.distance(p, point) < 10) {
        return point;
      }
    }
    return void 0;
  };

  pointerDown = function(e) {
    var foundPoint, p;
    p = new Point(e.clientX, e.clientY);
    if (!(foundPoint = findPointNear(p))) {
      model.points.push(p);
      foundPoint = p;
    }
    uistate.movingPoint = foundPoint;
    if (uistate.lastTouchedPoints[0] !== foundPoint) {
      return uistate.lastTouchedPoints.unshift(foundPoint);
    }
  };

  pointerMove = function(e) {
    uistate.pointerX = e.clientX;
    return uistate.pointerY = e.clientY;
  };

  pointerUp = function(e) {
    if (uistate.movingPoint) {
      return uistate.movingPoint = null;
    }
  };

  idle = function() {
    var originalFixed, point;
    if (point = uistate.movingPoint) {
      point.x = uistate.pointerX;
      point.y = uistate.pointerY;
      originalFixed = point.fixed;
      point.fixed = true;
      enforceConstraints();
      point.fixed = false;
      enforceConstraints();
      point.fixed = originalFixed;
    } else {
      enforceConstraints();
    }
    return render();
  };

  key("D", function() {
    var constraint, distance, p1, p2;
    p1 = uistate.lastTouchedPoints[0];
    p2 = uistate.lastTouchedPoints[1];
    distance = math.distance(p1, p2);
    constraint = new DistanceConstraint(p1, p2, distance);
    model.constraints.push(constraint);
    return render();
  });

  key("A", function() {
    var angle, constraint, p1, p2;
    p1 = uistate.lastTouchedPoints[0];
    p2 = uistate.lastTouchedPoints[1];
    angle = math.angle(p1, p2);
    constraint = new AngleConstraint(p1, p2, angle);
    model.constraints.push(constraint);
    return render();
  });

  key("F", function() {
    var p;
    p = uistate.lastTouchedPoints[0];
    return p.fixed = !p.fixed;
  });

  math = {};

  math.distance = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  };

  math.angle = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return Math.atan2(dy, dx);
  };

  math.normalize = function(p) {
    var d;
    d = Math.sqrt(p.x * p.x + p.y * p.y);
    return new Point(p.x / d, p.y / d);
  };

  window.config = config = {
    epsilon: 1e-2,
    stepSize: 0.1,
    maxIterations: 400
  };

  enforceConstraints = function() {
    var constraint, delta, dx, dy, e, iteration, moves, point, pointName, pointNames, solvedPoint, _i, _j, _k, _len, _len1, _ref, _ref1, _results;
    _results = [];
    for (iteration = _i = 0, _ref = config.maxIterations; 0 <= _ref ? _i < _ref : _i > _ref; iteration = 0 <= _ref ? ++_i : --_i) {
      moves = [];
      _ref1 = model.constraints;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        constraint = _ref1[_j];
        e = constraint.error();
        if (e > config.epsilon) {
          pointNames = constraint.pointNames();
          pointNames = _.reject(pointNames, function(pointName) {
            return constraint[pointName].fixed;
          });
          for (_k = 0, _len1 = pointNames.length; _k < _len1; _k++) {
            pointName = pointNames[_k];
            point = constraint[pointName];
            solvedPoint = constraint.solveFor(pointName);
            dx = solvedPoint.x - point.x;
            dy = solvedPoint.y - point.y;
            delta = new Point(dx, dy);
            moves.push({
              point: point,
              delta: delta
            });
          }
        }
      }
      if (moves.length === 0) {
        break;
      }
      _results.push((function() {
        var _l, _len2, _ref2, _results1;
        _results1 = [];
        for (_l = 0, _len2 = moves.length; _l < _len2; _l++) {
          _ref2 = moves[_l], point = _ref2.point, delta = _ref2.delta;
          point.x += delta.x * config.stepSize;
          _results1.push(point.y += delta.y * config.stepSize);
        }
        return _results1;
      })());
    }
    return _results;
  };

  init();

}).call(this);
